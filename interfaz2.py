# -*- coding: utf-8 -*-
"""Interfaz2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uBWvYL9I_ljm5A9LuO12PEr08Hw_xqGE
"""

# clima_app.py
import streamlit as st
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, roc_auc_score, roc_curve, ConfusionMatrixDisplay
from sklearn.preprocessing import LabelEncoder, LabelBinarizer
from mlxtend.plotting import plot_learning_curves
from PIL import Image

st.title('üå¶ Clasificaci√≥n Clim√°tica con Random Forest')

# Imagen ilustrativa
try:
    image = Image.open("clima1.jpeg")
    st.image(image, caption="Condiciones clim√°ticas representativas", use_container_width=True)
except:
    st.warning("No se pudo cargar la imagen 'clima1.jpeg'. Aseg√∫rate de que est√© en la misma carpeta.")

# Ingreso manual de variables
st.header("üî¢ Ingrese los valores para la predicci√≥n")

cloud_cover_options = ['partly cloudy', 'clear', 'overcast', 'cloudy']
season_options = ['Winter', 'Spring', 'Summer', 'Autumn']
location_options = ['inland', 'mountain', 'coastal']

Temperature = st.number_input("Temperatura (¬∞C)", value=20.0)
Humidity = st.slider("Humedad relativa (%)", 0, 100, 70)
Wind_Speed = st.number_input("Velocidad del viento (km/h)", value=10.0)
Precipitation = st.slider("Precipitaci√≥n (%)", 0, 100, 50)
Cloud_Cover = st.selectbox("Cobertura de nubes", cloud_cover_options)
Pressure = st.number_input("Presi√≥n atmosf√©rica (hPa)", value=1010.0)
UV_Index = st.slider("√çndice UV", 0, 14, 5)
Season = st.selectbox("Estaci√≥n", season_options)
Visibility = st.number_input("Visibilidad (km)", value=5.0)
Location = st.selectbox("Ubicaci√≥n", location_options)

# Cargar dataset
df = pd.read_csv("weather_classification_data.csv")  # Aseg√∫rate de tener este archivo en la misma carpeta

# Sidebar para mostrar datos
st.sidebar.header("üìÇ Fuente de datos")
if st.sidebar.checkbox("Mostrar muestra del dataset"):
    num_rows = st.sidebar.slider("N√∫mero de filas a mostrar", 1, 20, 5)
    st.subheader("üìã Muestra del dataset")
    st.dataframe(df.head(num_rows))

# Preparaci√≥n de datos
target = 'Weather Type'
df_encoded = df.copy()
cat_cols = ['Cloud Cover', 'Season', 'Location', target]
encoders = {col: LabelEncoder().fit(df[col]) for col in cat_cols}
for col in cat_cols:
    df_encoded[col] = encoders[col].transform(df[col])

X = df_encoded.drop(columns=[target])
y = df_encoded[target]
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Sidebar de hiperpar√°metros
st.sidebar.header("‚öôÔ∏è Hiperpar√°metros del modelo")
st.sidebar.markdown("""
- n_estimators: 100
- max_depth: 10
- min_samples_split: 5
""")

clf = RandomForestClassifier(n_estimators=100, max_depth=10, min_samples_split=5, random_state=42)
clf.fit(X_train, y_train)
y_pred = clf.predict(X_test)
y_prob = clf.predict_proba(X_test)

# Predicci√≥n
input_dict = {
    'Temperature': Temperature,
    'Humidity': Humidity,
    'Wind Speed': Wind_Speed,
    'Precipitation (%)': Precipitation,
    'Cloud Cover': encoders['Cloud Cover'].transform([Cloud_Cover])[0],
    'Atmospheric Pressure': Pressure,
    'UV Index': UV_Index,
    'Season': encoders['Season'].transform([Season])[0],
    'Visibility (km)': Visibility,
    'Location': encoders['Location'].transform([Location])[0]
}

input_array = np.array([list(input_dict.values())])

# Bot√≥n de predicci√≥n
if st.button("üå§Ô∏è Predecir tipo de clima"):
    prediction = clf.predict(input_array)[0]
    prediction_label = encoders[target].inverse_transform([prediction])[0]
    probabilities = clf.predict_proba(input_array)[0]

    st.subheader(f"üå§Ô∏è Clima predicho: **{prediction_label}**")

    # Mostrar imagen correspondiente
    try:
        clima_img = Image.open(f"{prediction_label}.jpg")
        st.image(clima_img, caption=f"Condiciones: {prediction_label}", use_container_width=True)
    except FileNotFoundError:
        st.warning(f"No se encontr√≥ imagen para '{prediction_label}.jpg'.")

    # Mostrar probabilidades
    prob_df = pd.DataFrame({
        'Tipo de Clima': encoders[target].inverse_transform(clf.classes_),
        'Probabilidad': probabilities
    }).sort_values(by='Probabilidad', ascending=False).reset_index(drop=True)

    st.subheader("üìã Probabilidades por clase")
    st.table(prob_df.style.format({'Probabilidad': '{:.2%}'}))

# M√©tricas
st.subheader("üìä M√©tricas del modelo")
acc = accuracy_score(y_test, y_pred)
prec = precision_score(y_test, y_pred, average='macro')
rec = recall_score(y_test, y_pred, average='macro')
f1 = f1_score(y_test, y_pred, average='macro')

met_df = pd.DataFrame([
    ['Accuracy', acc],
    ['Precision', prec],
    ['Recall', rec],
    ['F1 Score', f1]
], columns=['M√©trica', 'Valor'])

st.write(met_df.style.background_gradient(cmap='PuBu').bar(subset=['Valor'], color='#0A3871'))

# Matriz de confusi√≥n
if st.sidebar.checkbox("Mostrar matriz de confusi√≥n"):
    st.subheader("üìâ Matriz de Confusi√≥n")
    fig, ax = plt.subplots()
    ConfusionMatrixDisplay.from_estimator(clf, X_test, y_test, ax=ax, cmap='PuBu')
    ax.set_title("Matriz de Confusi√≥n")
    st.pyplot(fig)

# Curva ROC
if st.sidebar.checkbox("Mostrar curva ROC"):
    st.subheader("üìà Curva ROC")
    binarizer = LabelBinarizer().fit(y_train)
    y_test_bin = binarizer.transform(y_test)
    fig_roc, ax = plt.subplots()
    for i in range(len(clf.classes_)):
        fpr, tpr, _ = roc_curve(y_test_bin[:, i], y_prob[:, i])
        roc_auc = roc_auc_score(y_test_bin[:, i], y_prob[:, i])
        ax.plot(fpr, tpr, label=f'Clase {i} (AUC={roc_auc:.2f})')
    ax.plot([0, 1], [0, 1], 'k--')
    ax.legend()
    ax.set_xlabel('FPR')
    ax.set_ylabel('TPR')
    ax.set_title('Curva ROC')
    st.pyplot(fig_roc)

# Curva de aprendizaje
if st.sidebar.checkbox("Mostrar curva de aprendizaje"):
    st.subheader("üìâ Bias vs Variance")
    fig_bias = plt.figure()
    plot_learning_curves(X_train, y_train, X_test, y_test, clf, style='fast', test_marker='o')
    plt.xlabel("N√∫mero de muestras de entrenamiento")
    plt.ylabel("Error")
    st.pyplot(fig_bias)